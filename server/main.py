#!/usr/bin/env python3
"""
TalkBack Agent Analysis Server

A FastAPI server that receives TalkBack utterances from an Android device
and analyzes them for accessibility issues using a local LLM via Ollama.

Endpoints:
    GET  /              Debug dashboard (HTML)
    GET  /docs          Swagger UI (auto-generated by FastAPI)
    GET  /health        Health check
    POST /analyze       Batch utterance analysis
    WS   /stream        Streaming utterance analysis
    POST /skill/execute Queue a skill for device execution
    GET  /skill/pending Device polls for pending skills
    POST /skill/result  Device reports skill result
    GET  /skill/history Skill execution history
    POST /session/start Start a new recording session
    GET  /session        Current session summary
    GET  /session/export Export session as JSON or Markdown
    POST /session/end   End current session
    POST /session/note  Add a note to the session

Usage:
    python main.py
    python main.py --port 8080 --model phi4:14b-q4_K_M
    python main.py --no-mdns  # Disable mDNS/Bonjour discovery

Setup:
    1. Install Ollama: brew install ollama (macOS) or see https://ollama.ai
    2. Pull a model: ollama pull phi4:14b-q4_K_M
    3. pip install -r requirements.txt
    4. python main.py
    5. On device: adb reverse tcp:8080 tcp:8080
"""

from __future__ import annotations

import argparse
import logging
import socket
import time
from contextlib import asynccontextmanager
from typing import Optional

import uvicorn
from fastapi import FastAPI, Query, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse

from analyzer import AccessibilityAnalyzer
from device_settings import DeviceSettings, device_settings
from models import AnalysisRequest, AnalysisResponse, SkillCommand, SkillResult
from session import SessionManager, session_manager
from skills import SkillExecRequest, SkillExecResponse, SkillResultReport, skill_queue

logger = logging.getLogger("talkback-agent-server")

# Globals
analyzer: AccessibilityAnalyzer | None = None
zeroconf_instance = None
start_time: float = 0


def register_mdns(port: int) -> None:
    """Register mDNS/Bonjour service for device discovery."""
    global zeroconf_instance
    try:
        from zeroconf import ServiceInfo, Zeroconf

        zeroconf_instance = Zeroconf()
        hostname = socket.gethostname()
        ip = socket.gethostbyname(hostname)

        service_info = ServiceInfo(
            "_talkback-agent._tcp.local.",
            f"TalkBack Agent Server._talkback-agent._tcp.local.",
            addresses=[socket.inet_aton(ip)],
            port=port,
            properties={"version": "1.0", "hostname": hostname},
        )

        zeroconf_instance.register_service(service_info)
        logger.info(f"mDNS: Server discoverable as '{hostname}' at {ip}:{port}")
    except ImportError:
        logger.warning("zeroconf not installed, mDNS discovery disabled")
    except Exception as e:
        logger.warning(f"mDNS registration failed: {e}")


def unregister_mdns() -> None:
    """Unregister mDNS service."""
    global zeroconf_instance
    if zeroconf_instance:
        zeroconf_instance.unregister_all_services()
        zeroconf_instance.close()
        zeroconf_instance = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Server startup and shutdown."""
    global analyzer, start_time
    start_time = time.time()

    # Initialize analyzer
    model = app.state.model_name if hasattr(app.state, "model_name") else "phi4:14b-q4_K_M"
    analyzer = AccessibilityAnalyzer(model=model)
    logger.info(f"Analyzer initialized with model: {model}")

    # Register mDNS if enabled
    if getattr(app.state, "mdns_enabled", True):
        port = getattr(app.state, "port", 8080)
        register_mdns(port)

    yield

    # Shutdown
    skill_queue.clear()
    unregister_mdns()
    logger.info("Server shutting down")


app = FastAPI(
    title="TalkBack Agent Analysis Server",
    description=(
        "Analyzes TalkBack screen reader utterances for accessibility issues. "
        "Supports batch analysis, streaming, remote skill execution, and session recording."
    ),
    version="1.0.0",
    lifespan=lifespan,
)


# ── Debug Dashboard ───────────────────────────────────────────────


DASHBOARD_HTML = """<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TalkBack Agent Dashboard</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         background: #0d1117; color: #c9d1d9; padding: 24px; }
  h1 { color: #58a6ff; margin-bottom: 8px; }
  h2 { color: #8b949e; font-size: 14px; margin-bottom: 24px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; }
  .card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; }
  .card h3 { color: #58a6ff; font-size: 14px; text-transform: uppercase; margin-bottom: 12px; }
  .stat { font-size: 32px; font-weight: bold; color: #f0f6fc; }
  .stat-label { font-size: 12px; color: #8b949e; margin-top: 4px; }
  .badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; }
  .badge-ok { background: #238636; color: #fff; }
  .badge-warn { background: #9e6a03; color: #fff; }
  .badge-err { background: #da3633; color: #fff; }
  table { width: 100%; border-collapse: collapse; margin-top: 8px; }
  th, td { text-align: left; padding: 6px 8px; border-bottom: 1px solid #21262d; font-size: 13px; }
  th { color: #8b949e; }
  a { color: #58a6ff; text-decoration: none; }
  a:hover { text-decoration: underline; }
  .links { margin-top: 24px; }
  .links a { margin-right: 16px; }
  #log { background: #0d1117; border: 1px solid #30363d; border-radius: 4px;
         padding: 8px; font-family: monospace; font-size: 12px; height: 200px;
         overflow-y: auto; margin-top: 8px; white-space: pre-wrap; }
  .refresh-btn { background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
                 padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
  .refresh-btn:hover { background: #30363d; }
</style>
</head>
<body>
<h1>TalkBack Agent</h1>
<h2>Accessibility Analysis Server</h2>

<div class="grid" id="dashboard">
  <div class="card">
    <h3>Server Status</h3>
    <div id="status">Loading...</div>
  </div>
  <div class="card">
    <h3>Session</h3>
    <div id="session">No active session</div>
  </div>
  <div class="card">
    <h3>Pending Skills</h3>
    <div id="skills">None</div>
  </div>
  <div class="card">
    <h3>Recent Issues</h3>
    <div id="issues">None yet</div>
  </div>
</div>

<div class="links">
  <a href="/docs">Swagger UI</a>
  <a href="/redoc">ReDoc</a>
  <a href="/health">Health JSON</a>
  <a href="/session">Session JSON</a>
  <a href="/session/export?format=markdown">Export Markdown</a>
  <a href="/session/export?format=json">Export JSON</a>
  <a href="/settings">Settings JSON</a>
  <button class="refresh-btn" onclick="refresh()">Refresh</button>
  <button class="refresh-btn" onclick="toggleTts()" id="ttsBtn">Toggle TTS</button>
</div>

<div class="card" style="margin-top: 16px;">
  <h3>Live Log</h3>
  <div id="log">Connecting...</div>
</div>

<script>
async function refresh() {
  // Health
  try {
    const h = await (await fetch('/health')).json();
    document.getElementById('status').innerHTML = `
      <span class="badge badge-ok">Connected</span>
      <div style="margin-top:8px">
        <div class="stat-label">Model</div>
        <div>${h.model}</div>
        <div class="stat-label" style="margin-top:4px">Uptime</div>
        <div>${h.uptime_seconds}s</div>
        <div class="stat-label" style="margin-top:4px">TTS</div>
        <div>${h.tts_suppressed ? '<span class="badge badge-warn">Suppressed</span>' : '<span class="badge badge-ok">Active</span>'}</div>
      </div>`;
    window._ttsSuppressed = h.tts_suppressed;
    document.getElementById('ttsBtn').textContent = h.tts_suppressed ? 'Enable TTS' : 'Suppress TTS';
  } catch(e) {
    document.getElementById('status').innerHTML = '<span class="badge badge-err">Offline</span>';
  }

  // Session
  try {
    const s = await (await fetch('/session')).json();
    if (s.session_id) {
      document.getElementById('session').innerHTML = `
        <div class="stat">${s.total_issues}</div>
        <div class="stat-label">Issues Found</div>
        <table>
          <tr><td>Utterances</td><td>${s.total_utterances}</td></tr>
          <tr><td>Analyses</td><td>${s.total_analyses}</td></tr>
          <tr><td>Duration</td><td>${s.duration_seconds}s</td></tr>
        </table>`;
    }
  } catch(e) {}

  // Skills
  try {
    const sk = await (await fetch('/skill/pending')).json();
    if (sk.length > 0) {
      document.getElementById('skills').innerHTML = sk.map(s =>
        `<div>${s.skill_name} (${s.request_id})</div>`
      ).join('');
    } else {
      document.getElementById('skills').innerHTML = 'None pending';
    }
  } catch(e) {}
}

async function toggleTts() {
  const suppress = !window._ttsSuppressed;
  await fetch('/settings/tts?suppress=' + suppress, {method: 'POST'});
  refresh();
}

// Auto-refresh every 3s
refresh();
setInterval(refresh, 3000);

// WebSocket log
try {
  const ws = new WebSocket(`ws://${location.host}/dashboard/ws`);
  const logEl = document.getElementById('log');
  ws.onmessage = (e) => {
    logEl.textContent += e.data + '\\n';
    logEl.scrollTop = logEl.scrollHeight;
  };
  ws.onopen = () => { logEl.textContent = 'Connected to live log\\n'; };
  ws.onclose = () => { logEl.textContent += 'Disconnected\\n'; };
} catch(e) {
  document.getElementById('log').textContent = 'WebSocket not available';
}
</script>
</body>
</html>"""


@app.get("/", response_class=HTMLResponse)
async def dashboard():
    """Debug dashboard with live server status."""
    return DASHBOARD_HTML


# ── Dashboard WebSocket (live log) ────────────────────────────────

_dashboard_clients: list[WebSocket] = []


@app.websocket("/dashboard/ws")
async def dashboard_ws(websocket: WebSocket):
    """WebSocket for live log streaming to the dashboard."""
    await websocket.accept()
    _dashboard_clients.append(websocket)
    try:
        while True:
            await websocket.receive_text()  # Keep alive
    except WebSocketDisconnect:
        _dashboard_clients.remove(websocket)


async def broadcast_log(message: str):
    """Send a log message to all connected dashboard clients."""
    for ws in list(_dashboard_clients):
        try:
            await ws.send_text(message)
        except Exception:
            _dashboard_clients.remove(ws)


# ── Core Analysis Endpoints ───────────────────────────────────────


@app.get("/health")
async def health():
    """Health check endpoint. Used by Android client for connection verification."""
    uptime = int(time.time() - start_time)
    return {
        "status": "ok",
        "model": analyzer.model if analyzer else "not initialized",
        "uptime_seconds": uptime,
        "active_session": session_manager.current.session_id,
        "tts_suppressed": device_settings.current.tts_suppressed,
        "settings_revision": device_settings.current.revision,
    }


@app.post("/analyze", response_model=AnalysisResponse)
async def analyze(request: AnalysisRequest):
    """
    Analyze a batch of TalkBack utterances for accessibility issues.

    The Android client sends buffered utterances along with navigation context.
    The server runs LLM inference and returns structured issue reports.
    """
    if analyzer is None:
        return JSONResponse(
            status_code=503,
            content={"error": "Analyzer not initialized"},
        )

    logger.info(
        f"Analyzing {len(request.utterances)} utterances "
        f"(trigger: {request.context.trigger})"
    )

    # Record in session
    session_manager.current.record_utterances(request)

    response = await analyzer.analyze(request)

    # Record results in session
    session_manager.current.record_analysis(request, response)

    issue_count = len(response.issues)
    inference_ms = response.metadata.inference_time_ms if response.metadata else "?"
    log_msg = f"Analysis: {len(request.utterances)} utterances -> {issue_count} issues ({inference_ms}ms)"
    logger.info(log_msg)
    await broadcast_log(log_msg)

    return response


@app.websocket("/stream")
async def stream_analysis(websocket: WebSocket):
    """
    WebSocket endpoint for streaming analysis.
    The client sends utterance events as they occur, and receives
    analysis results as they're generated.
    """
    await websocket.accept()
    buffer: list = []

    try:
        while True:
            data = await websocket.receive_json()
            msg_type = data.get("type", "")

            if msg_type == "utterance":
                buffer.append(data.get("event", {}))

                event = data.get("event", {})
                nav_type = event.get("navigation", "UNKNOWN")

                if len(buffer) >= 20 or nav_type in ("SCREEN_CHANGE", "WINDOW_CHANGE"):
                    if analyzer and buffer:
                        request = AnalysisRequest(
                            utterances=buffer,  # type: ignore
                            context=data.get("context", {}),  # type: ignore
                        )
                        session_manager.current.record_utterances(request)
                        response = await analyzer.analyze(request)
                        session_manager.current.record_analysis(request, response)
                        for issue in response.issues:
                            await websocket.send_json(
                                {"type": "issue", "data": issue.model_dump()}
                            )
                        buffer.clear()

            elif msg_type == "ping":
                await websocket.send_json({"type": "pong"})

    except WebSocketDisconnect:
        logger.info("WebSocket client disconnected")


# ── Skill Execution Endpoints ─────────────────────────────────────


@app.post("/skill/execute", response_model=SkillExecResponse)
async def skill_execute(request: SkillExecRequest):
    """
    Queue a skill for execution on the Android device.
    Blocks until the device picks it up and reports the result, or times out.

    Example skills: NavigateToElement, ActivateElement, CollectScreenUtterances,
    ScreenSnapshot, FillTextField, ScrollAndCollect, WaitForText
    """
    log_msg = f"Skill queued: {request.skill_name} (timeout: {request.timeout_ms}ms)"
    logger.info(log_msg)
    await broadcast_log(log_msg)

    result = await skill_queue.execute(request)

    session_manager.current.record_skill(
        request.skill_name, result.success, result.message
    )

    log_msg = f"Skill done: {request.skill_name} success={result.success}"
    await broadcast_log(log_msg)

    return result


@app.get("/skill/pending")
async def skill_pending():
    """
    Get pending skill commands (polled by Android device).
    The device should call this periodically and execute any pending skills.
    """
    return skill_queue.get_pending()


@app.post("/skill/result")
async def skill_result(result: SkillResultReport):
    """
    Report the result of a skill execution (called by Android device).
    """
    found = skill_queue.report_result(result)
    if not found:
        return JSONResponse(
            status_code=404,
            content={"error": f"No pending skill with id {result.request_id}"},
        )
    return {"status": "ok"}


@app.get("/skill/history")
async def skill_history(limit: int = Query(default=50, le=200)):
    """Get recent skill execution history."""
    return skill_queue.get_history(limit)


# ── Session Endpoints ─────────────────────────────────────────────


@app.post("/session/start")
async def session_start(session_id: Optional[str] = None):
    """Start a new recording session."""
    session = session_manager.start_new(session_id)
    log_msg = f"Session started: {session.session_id}"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {"session_id": session.session_id}


@app.get("/session")
async def session_status():
    """Get current session summary."""
    return session_manager.current.get_summary()


@app.get("/session/export")
async def session_export(format: str = Query(default="json", pattern="^(json|markdown)$")):
    """Export current session as JSON or Markdown."""
    session = session_manager.current
    if format == "markdown":
        return PlainTextResponse(
            session.export_markdown(),
            media_type="text/markdown",
        )
    return JSONResponse(content=__import__("json").loads(session.export_json()))


@app.post("/session/end")
async def session_end(save: bool = Query(default=True)):
    """End the current session. Optionally save to disk."""
    session = session_manager.current
    if save:
        path = session.save()
        logger.info(f"Session saved: {path}")

    summary = session_manager.end_current()
    if summary is None:
        return {"status": "no active session"}

    log_msg = f"Session ended: {summary.total_issues} issues in {summary.duration_seconds}s"
    await broadcast_log(log_msg)
    return summary


@app.post("/session/note")
async def session_note(note: str):
    """Add a note to the current session."""
    session_manager.current.add_note(note)
    return {"status": "ok"}


@app.get("/session/history")
async def session_history():
    """Get list of past sessions."""
    return session_manager.get_history()


# ── Device Settings Endpoints ─────────────────────────────────────


@app.get("/settings")
async def get_settings(revision: int = Query(default=0)):
    """
    Get current device settings.

    If `revision` is provided, returns settings only if they've changed
    since that revision (304 Not Modified otherwise). This allows efficient
    polling by the device.
    """
    if revision > 0:
        updated = device_settings.get_if_newer(revision)
        if updated is None:
            return JSONResponse(status_code=304, content=None)
        return updated
    return device_settings.current


@app.patch("/settings")
async def update_settings(updates: dict):
    """
    Update one or more device settings.

    Accepts a JSON object with setting keys and their new values.
    Only known setting keys are applied; unknown keys are ignored.

    Example: {"tts_suppressed": true, "buffer_size": 10}
    """
    settings = device_settings.update(**updates)
    log_msg = f"Settings updated (rev {settings.revision}): {updates}"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return settings


@app.post("/settings/tts")
async def toggle_tts(suppress: bool = Query(...)):
    """
    Convenience endpoint to toggle TTS suppression.

    When suppressed, the device captures utterances silently without speaking.
    Useful for automated testing or reducing noise during analysis.

    Usage: POST /settings/tts?suppress=true
    """
    settings = device_settings.update(tts_suppressed=suppress)
    state = "suppressed" if suppress else "enabled"
    log_msg = f"TTS {state} (rev {settings.revision})"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {"tts_suppressed": settings.tts_suppressed, "revision": settings.revision}


# ── Legacy command endpoint (kept for backwards compat) ───────────


@app.post("/command")
async def execute_command(command: SkillCommand) -> SkillResult:
    """
    Legacy command endpoint. Use /skill/execute for new integrations.
    """
    logger.info(f"Legacy command: {command.skill_name}")
    return SkillResult(
        success=False,
        message="Use /skill/execute for remote skill execution",
    )


# ── Main ──────────────────────────────────────────────────────────


def main():
    parser = argparse.ArgumentParser(description="TalkBack Agent Analysis Server")
    parser.add_argument("--host", default="0.0.0.0", help="Bind host (default: 0.0.0.0)")
    parser.add_argument("--port", type=int, default=8080, help="Bind port (default: 8080)")
    parser.add_argument(
        "--model",
        default="phi4:14b-q4_K_M",
        help="Ollama model name (default: phi4:14b-q4_K_M)",
    )
    parser.add_argument("--no-mdns", action="store_true", help="Disable mDNS/Bonjour discovery")
    parser.add_argument("--log-level", default="info", help="Log level (default: info)")

    args = parser.parse_args()

    logging.basicConfig(
        level=getattr(logging, args.log_level.upper()),
        format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
    )

    # Pass config to app state
    app.state.model_name = args.model
    app.state.mdns_enabled = not args.no_mdns
    app.state.port = args.port

    logger.info(f"Starting server on {args.host}:{args.port}")
    logger.info(f"Model: {args.model}")
    logger.info(f"mDNS: {'enabled' if not args.no_mdns else 'disabled'}")
    logger.info("")
    logger.info("Endpoints:")
    logger.info(f"  Dashboard:  http://localhost:{args.port}/")
    logger.info(f"  Swagger UI: http://localhost:{args.port}/docs")
    logger.info(f"  Health:     http://localhost:{args.port}/health")
    logger.info("")
    logger.info("Setup:")
    logger.info("  1. Connect Android device via USB")
    logger.info(f"  2. Run: adb reverse tcp:{args.port} tcp:{args.port}")
    logger.info("  3. Enable TalkBack Agent in Accessibility settings")
    logger.info("")

    uvicorn.run(
        app,
        host=args.host,
        port=args.port,
        log_level=args.log_level,
    )


if __name__ == "__main__":
    main()
