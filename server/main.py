#!/usr/bin/env python3
"""
TalkBack Agent Analysis Server

A FastAPI server that receives TalkBack utterances from an Android device
and analyzes them for accessibility issues using a local LLM via Ollama.

Endpoints:
    GET  /              Debug dashboard (HTML)
    GET  /docs          Swagger UI (auto-generated by FastAPI)
    GET  /health        Health check
    POST /analyze       Batch utterance analysis
    WS   /stream        Streaming utterance analysis
    POST /skill/execute Queue a skill for device execution
    GET  /skill/pending Device polls for pending skills
    POST /skill/result  Device reports skill result
    GET  /skill/history Skill execution history
    POST /session/start Start a new recording session
    GET  /session        Current session summary
    GET  /session/export Export session as JSON or Markdown
    POST /session/end   End current session
    POST /session/note  Add a note to the session

Usage:
    python main.py
    python main.py --port 8080 --model phi4:14b-q4_K_M
    python main.py --no-mdns  # Disable mDNS/Bonjour discovery

Setup:
    1. Install Ollama: brew install ollama (macOS) or see https://ollama.ai
    2. Pull a model: ollama pull phi4:14b-q4_K_M
    3. pip install -r requirements.txt
    4. python main.py
    5. On device: adb reverse tcp:8080 tcp:8080
"""

from __future__ import annotations

import argparse
import logging
import socket
import time
from contextlib import asynccontextmanager
from typing import Optional

import uvicorn
from fastapi import Depends, FastAPI, Header, Query, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse

from pydantic import BaseModel

from analyzer import AccessibilityAnalyzer
from device_registry import DeviceInfo, DeviceRegistry, device_registry
from device_settings import DeviceSettings, device_settings
from gym import GymCompareRequest, GymRunRequest, gym_runner
from models import AnalysisRequest, AnalysisResponse, SkillCommand, SkillResult
from session import SessionManager, session_manager
from skills import SkillExecRequest, SkillExecResponse, SkillResultReport, skill_queue

logger = logging.getLogger("talkback-agent-server")

# Globals
analyzer: AccessibilityAnalyzer | None = None
zeroconf_instance = None
start_time: float = 0


# ── Auth dependency ──────────────────────────────────────────────


async def require_auth(x_agent_token: str = Header(default="")):
    """
    FastAPI dependency that validates X-Agent-Token on mutation endpoints.

    Returns early (no-op) if no devices have been approved yet — this avoids
    locking out the system before any device has gone through approval.
    Once at least one device is approved (or AGENT_AUTH_TOKEN env is set),
    all mutation requests must carry a valid token.
    """
    if not device_registry.auth_enabled:
        return  # No auth configured yet, allow all
    if not x_agent_token:
        raise _auth_error("Missing X-Agent-Token header")
    if not device_registry.validate_token(x_agent_token):
        raise _auth_error("Invalid auth token")


def _auth_error(detail: str):
    from fastapi import HTTPException
    return HTTPException(status_code=401, detail=detail)


def register_mdns(port: int) -> None:
    """Register mDNS/Bonjour service for device discovery."""
    global zeroconf_instance
    try:
        from zeroconf import ServiceInfo, Zeroconf

        zeroconf_instance = Zeroconf()
        hostname = socket.gethostname()
        ip = socket.gethostbyname(hostname)

        service_info = ServiceInfo(
            "_talkback-agent._tcp.local.",
            f"TalkBack Agent Server._talkback-agent._tcp.local.",
            addresses=[socket.inet_aton(ip)],
            port=port,
            properties={"version": "1.0", "hostname": hostname},
        )

        zeroconf_instance.register_service(service_info)
        logger.info(f"mDNS: Server discoverable as '{hostname}' at {ip}:{port}")
    except ImportError:
        logger.warning("zeroconf not installed, mDNS discovery disabled")
    except Exception as e:
        logger.warning(f"mDNS registration failed: {e}")


def unregister_mdns() -> None:
    """Unregister mDNS service."""
    global zeroconf_instance
    if zeroconf_instance:
        zeroconf_instance.unregister_all_services()
        zeroconf_instance.close()
        zeroconf_instance = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Server startup and shutdown."""
    global analyzer, start_time
    start_time = time.time()

    # Initialize analyzer
    model = app.state.model_name if hasattr(app.state, "model_name") else "phi4:14b-q4_K_M"
    analyzer = AccessibilityAnalyzer(model=model)
    logger.info(f"Analyzer initialized with model: {model}")

    # Register mDNS if enabled
    if getattr(app.state, "mdns_enabled", True):
        port = getattr(app.state, "port", 8080)
        register_mdns(port)

    yield

    # Shutdown
    skill_queue.clear()
    device_registry.clear()
    gym_runner.clear()
    unregister_mdns()
    logger.info("Server shutting down")


app = FastAPI(
    title="TalkBack Agent Analysis Server",
    description=(
        "Analyzes TalkBack screen reader utterances for accessibility issues. "
        "Supports batch analysis, streaming, remote skill execution, and session recording."
    ),
    version="1.0.0",
    lifespan=lifespan,
)


# ── Debug Dashboard ───────────────────────────────────────────────


DASHBOARD_HTML = """<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>TalkBack Agent Dashboard</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
         background: #0d1117; color: #c9d1d9; padding: 24px; }
  h1 { color: #58a6ff; margin-bottom: 8px; }
  h2 { color: #8b949e; font-size: 14px; margin-bottom: 24px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; }
  .card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 16px; }
  .card h3 { color: #58a6ff; font-size: 14px; text-transform: uppercase; margin-bottom: 12px; }
  .stat { font-size: 32px; font-weight: bold; color: #f0f6fc; }
  .stat-label { font-size: 12px; color: #8b949e; margin-top: 4px; }
  .badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; }
  .badge-ok { background: #238636; color: #fff; }
  .badge-warn { background: #9e6a03; color: #fff; }
  .badge-err { background: #da3633; color: #fff; }
  table { width: 100%; border-collapse: collapse; margin-top: 8px; }
  th, td { text-align: left; padding: 6px 8px; border-bottom: 1px solid #21262d; font-size: 13px; }
  th { color: #8b949e; }
  a { color: #58a6ff; text-decoration: none; }
  a:hover { text-decoration: underline; }
  .links { margin-top: 24px; }
  .links a { margin-right: 16px; }
  #log { background: #0d1117; border: 1px solid #30363d; border-radius: 4px;
         padding: 8px; font-family: monospace; font-size: 12px; height: 200px;
         overflow-y: auto; margin-top: 8px; white-space: pre-wrap; }
  .refresh-btn { background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
                 padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px; }
  .refresh-btn:hover { background: #30363d; }
</style>
</head>
<body>
<h1>TalkBack Agent</h1>
<h2>Accessibility Analysis Server</h2>

<div class="grid" id="dashboard">
  <div class="card">
    <h3>Server Status</h3>
    <div id="status">Loading...</div>
  </div>
  <div class="card">
    <h3>Session</h3>
    <div id="session">No active session</div>
  </div>
  <div class="card">
    <h3>Pending Skills</h3>
    <div id="skills">None</div>
  </div>
  <div class="card">
    <h3>Recent Issues</h3>
    <div id="issues">None yet</div>
  </div>
  <div class="card">
    <h3>Devices</h3>
    <div id="devices">No devices</div>
  </div>
</div>

<div class="links">
  <a href="/docs">Swagger UI</a>
  <a href="/redoc">ReDoc</a>
  <a href="/health">Health JSON</a>
  <a href="/session">Session JSON</a>
  <a href="/session/export?format=markdown">Export Markdown</a>
  <a href="/session/export?format=json">Export JSON</a>
  <a href="/settings">Settings JSON</a>
  <a href="/gym">Model Gym</a>
  <button class="refresh-btn" onclick="refresh()">Refresh</button>
  <button class="refresh-btn" onclick="toggleTts()" id="ttsBtn">Toggle TTS</button>
</div>

<div class="card" style="margin-top: 16px;">
  <h3>Live Log</h3>
  <div id="log">Connecting...</div>
</div>

<script>
async function refresh() {
  // Health
  try {
    const h = await (await fetch('/health')).json();
    document.getElementById('status').innerHTML = `
      <span class="badge badge-ok">Connected</span>
      <div style="margin-top:8px">
        <div class="stat-label">Model</div>
        <div>${h.model}</div>
        <div class="stat-label" style="margin-top:4px">Uptime</div>
        <div>${h.uptime_seconds}s</div>
        <div class="stat-label" style="margin-top:4px">TTS</div>
        <div>${h.tts_suppressed ? '<span class="badge badge-warn">Suppressed</span>' : '<span class="badge badge-ok">Active</span>'}</div>
      </div>`;
    window._ttsSuppressed = h.tts_suppressed;
    document.getElementById('ttsBtn').textContent = h.tts_suppressed ? 'Enable TTS' : 'Suppress TTS';
  } catch(e) {
    document.getElementById('status').innerHTML = '<span class="badge badge-err">Offline</span>';
  }

  // Session
  try {
    const s = await (await fetch('/session')).json();
    if (s.session_id) {
      document.getElementById('session').innerHTML = `
        <div class="stat">${s.total_issues}</div>
        <div class="stat-label">Issues Found</div>
        <table>
          <tr><td>Utterances</td><td>${s.total_utterances}</td></tr>
          <tr><td>Analyses</td><td>${s.total_analyses}</td></tr>
          <tr><td>Duration</td><td>${s.duration_seconds}s</td></tr>
        </table>`;
    }
  } catch(e) {}

  // Skills
  try {
    const sk = await (await fetch('/skill/pending')).json();
    if (sk.length > 0) {
      document.getElementById('skills').innerHTML = sk.map(s =>
        `<div>${s.skill_name} (${s.request_id})</div>`
      ).join('');
    } else {
      document.getElementById('skills').innerHTML = 'None pending';
    }
  } catch(e) {}

  // Devices
  try {
    const devs = await (await fetch('/device/all')).json();
    if (devs.length > 0) {
      document.getElementById('devices').innerHTML = devs.map(d => {
        let badge = d.status === 'approved'
          ? '<span class="badge badge-ok">Approved</span>'
          : d.status === 'pending'
            ? '<span class="badge badge-warn">Pending</span>'
            : '<span class="badge badge-err">Rejected</span>';
        let actions = d.status === 'pending'
          ? ` <button class="refresh-btn" onclick="approveDevice('${d.device_id}')">Approve</button>`
            + ` <button class="refresh-btn" onclick="rejectDevice('${d.device_id}')">Reject</button>`
          : '';
        let tokenInfo = d.status === 'approved' && d.auth_token
          ? `<div class="stat-label" style="margin-top:4px">Token: <code>${d.auth_token.substring(0,8)}...</code></div>`
          : '';
        return `<div style="margin-bottom:8px">${badge} ${d.device_name || d.device_id}${actions}${tokenInfo}</div>`;
      }).join('');
    } else {
      document.getElementById('devices').innerHTML = 'No devices registered';
    }
  } catch(e) {}
}

async function toggleTts() {
  const suppress = !window._ttsSuppressed;
  await fetch('/settings/tts?suppress=' + suppress, {method: 'POST'});
  refresh();
}

async function approveDevice(deviceId) {
  await fetch('/device/approve/' + deviceId, {method: 'POST'});
  refresh();
}

async function rejectDevice(deviceId) {
  await fetch('/device/reject/' + deviceId, {method: 'POST'});
  refresh();
}

// Auto-refresh every 3s
refresh();
setInterval(refresh, 3000);

// WebSocket log
try {
  const ws = new WebSocket(`ws://${location.host}/dashboard/ws`);
  const logEl = document.getElementById('log');
  ws.onmessage = (e) => {
    logEl.textContent += e.data + '\\n';
    logEl.scrollTop = logEl.scrollHeight;
  };
  ws.onopen = () => { logEl.textContent = 'Connected to live log\\n'; };
  ws.onclose = () => { logEl.textContent += 'Disconnected\\n'; };
} catch(e) {
  document.getElementById('log').textContent = 'WebSocket not available';
}
</script>
</body>
</html>"""


@app.get("/", response_class=HTMLResponse)
async def dashboard():
    """Debug dashboard with live server status."""
    return DASHBOARD_HTML


# ── Dashboard WebSocket (live log) ────────────────────────────────

_dashboard_clients: list[WebSocket] = []


@app.websocket("/dashboard/ws")
async def dashboard_ws(websocket: WebSocket):
    """WebSocket for live log streaming to the dashboard."""
    await websocket.accept()
    _dashboard_clients.append(websocket)
    try:
        while True:
            await websocket.receive_text()  # Keep alive
    except WebSocketDisconnect:
        _dashboard_clients.remove(websocket)


async def broadcast_log(message: str):
    """Send a log message to all connected dashboard clients."""
    for ws in list(_dashboard_clients):
        try:
            await ws.send_text(message)
        except Exception:
            _dashboard_clients.remove(ws)


# ── Core Analysis Endpoints ───────────────────────────────────────


@app.get("/health")
async def health():
    """Health check endpoint. Used by Android client for connection verification."""
    uptime = int(time.time() - start_time)
    return {
        "status": "ok",
        "model": analyzer.model if analyzer else "not initialized",
        "uptime_seconds": uptime,
        "active_session": session_manager.current.session_id,
        "tts_suppressed": device_settings.current.tts_suppressed,
        "settings_revision": device_settings.current.revision,
        "auth_enabled": device_registry.auth_enabled,
        "pending_devices": len(device_registry.get_pending()),
    }


@app.post("/analyze", response_model=AnalysisResponse, dependencies=[Depends(require_auth)])
async def analyze(request: AnalysisRequest):
    """
    Analyze a batch of TalkBack utterances for accessibility issues.

    The Android client sends buffered utterances along with navigation context.
    The server runs LLM inference and returns structured issue reports.
    """
    if analyzer is None:
        return JSONResponse(
            status_code=503,
            content={"error": "Analyzer not initialized"},
        )

    logger.info(
        f"Analyzing {len(request.utterances)} utterances "
        f"(trigger: {request.context.trigger})"
    )

    # Record in session
    session_manager.current.record_utterances(request)

    response = await analyzer.analyze(request)

    # Record results in session
    session_manager.current.record_analysis(request, response)

    issue_count = len(response.issues)
    inference_ms = response.metadata.inference_time_ms if response.metadata else "?"
    log_msg = f"Analysis: {len(request.utterances)} utterances -> {issue_count} issues ({inference_ms}ms)"
    logger.info(log_msg)
    await broadcast_log(log_msg)

    return response


@app.websocket("/stream")
async def stream_analysis(websocket: WebSocket):
    """
    WebSocket endpoint for streaming analysis.
    The client sends utterance events as they occur, and receives
    analysis results as they're generated.
    """
    await websocket.accept()
    buffer: list = []

    try:
        while True:
            data = await websocket.receive_json()
            msg_type = data.get("type", "")

            if msg_type == "utterance":
                buffer.append(data.get("event", {}))

                event = data.get("event", {})
                nav_type = event.get("navigation", "UNKNOWN")

                if len(buffer) >= 20 or nav_type in ("SCREEN_CHANGE", "WINDOW_CHANGE"):
                    if analyzer and buffer:
                        request = AnalysisRequest(
                            utterances=buffer,  # type: ignore
                            context=data.get("context", {}),  # type: ignore
                        )
                        session_manager.current.record_utterances(request)
                        response = await analyzer.analyze(request)
                        session_manager.current.record_analysis(request, response)
                        for issue in response.issues:
                            await websocket.send_json(
                                {"type": "issue", "data": issue.model_dump()}
                            )
                        buffer.clear()

            elif msg_type == "ping":
                await websocket.send_json({"type": "pong"})

    except WebSocketDisconnect:
        logger.info("WebSocket client disconnected")


# ── Skill Execution Endpoints ─────────────────────────────────────


@app.post("/skill/execute", response_model=SkillExecResponse, dependencies=[Depends(require_auth)])
async def skill_execute(request: SkillExecRequest):
    """
    Queue a skill for execution on the Android device.
    Blocks until the device picks it up and reports the result, or times out.

    Example skills: NavigateToElement, ActivateElement, CollectScreenUtterances,
    ScreenSnapshot, FillTextField, ScrollAndCollect, WaitForText
    """
    log_msg = f"Skill queued: {request.skill_name} (timeout: {request.timeout_ms}ms)"
    logger.info(log_msg)
    await broadcast_log(log_msg)

    result = await skill_queue.execute(request)

    session_manager.current.record_skill(
        request.skill_name, result.success, result.message
    )

    log_msg = f"Skill done: {request.skill_name} success={result.success}"
    await broadcast_log(log_msg)

    return result


@app.get("/skill/pending")
async def skill_pending():
    """
    Get pending skill commands (polled by Android device).
    The device should call this periodically and execute any pending skills.
    """
    return skill_queue.get_pending()


@app.post("/skill/result", dependencies=[Depends(require_auth)])
async def skill_result(result: SkillResultReport):
    """
    Report the result of a skill execution (called by Android device).
    """
    found = skill_queue.report_result(result)
    if not found:
        return JSONResponse(
            status_code=404,
            content={"error": f"No pending skill with id {result.request_id}"},
        )
    return {"status": "ok"}


@app.get("/skill/history")
async def skill_history(limit: int = Query(default=50, le=200)):
    """Get recent skill execution history."""
    return skill_queue.get_history(limit)


# ── Session Endpoints ─────────────────────────────────────────────


@app.post("/session/start", dependencies=[Depends(require_auth)])
async def session_start(session_id: Optional[str] = None):
    """Start a new recording session."""
    session = session_manager.start_new(session_id)
    log_msg = f"Session started: {session.session_id}"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {"session_id": session.session_id}


@app.get("/session")
async def session_status():
    """Get current session summary."""
    return session_manager.current.get_summary()


@app.get("/session/export")
async def session_export(format: str = Query(default="json", pattern="^(json|markdown)$")):
    """Export current session as JSON or Markdown."""
    session = session_manager.current
    if format == "markdown":
        return PlainTextResponse(
            session.export_markdown(),
            media_type="text/markdown",
        )
    return JSONResponse(content=__import__("json").loads(session.export_json()))


@app.post("/session/end", dependencies=[Depends(require_auth)])
async def session_end(save: bool = Query(default=True)):
    """End the current session. Optionally save to disk."""
    session = session_manager.current
    if save:
        path = session.save()
        logger.info(f"Session saved: {path}")

    summary = session_manager.end_current()
    if summary is None:
        return {"status": "no active session"}

    log_msg = f"Session ended: {summary.total_issues} issues in {summary.duration_seconds}s"
    await broadcast_log(log_msg)
    return summary


@app.post("/session/note", dependencies=[Depends(require_auth)])
async def session_note(note: str):
    """Add a note to the current session."""
    session_manager.current.add_note(note)
    return {"status": "ok"}


@app.get("/session/history")
async def session_history():
    """Get list of past sessions."""
    return session_manager.get_history()


# ── Device Settings Endpoints ─────────────────────────────────────


@app.get("/settings")
async def get_settings(
    revision: int = Query(default=0),
    device_id: str = Query(default=""),
):
    """
    Get current device settings.

    If `revision` is provided, returns settings only if they've changed
    since that revision (304 Not Modified otherwise). This allows efficient
    polling by the device.

    If `device_id` is provided and the device has been approved, the response
    includes `auth_token` so the device can start authenticating.
    """
    if revision > 0:
        updated = device_settings.get_if_newer(revision)
        if updated is None:
            # Even on 304, check if a token is newly available
            if device_id:
                token = device_registry.get_token_for_device(device_id)
                if token:
                    return {"auth_token": token, "_token_only": True}
            return JSONResponse(status_code=304, content=None)
        settings_dict = updated.model_dump()
    else:
        settings_dict = device_settings.current.model_dump()

    # Attach auth token if device is approved
    if device_id:
        token = device_registry.get_token_for_device(device_id)
        if token:
            settings_dict["auth_token"] = token

    return settings_dict


@app.patch("/settings", dependencies=[Depends(require_auth)])
async def update_settings(updates: dict):
    """
    Update one or more device settings.

    Accepts a JSON object with setting keys and their new values.
    Only known setting keys are applied; unknown keys are ignored.

    Example: {"tts_suppressed": true, "buffer_size": 10}
    """
    settings = device_settings.update(**updates)
    log_msg = f"Settings updated (rev {settings.revision}): {updates}"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return settings


@app.post("/settings/tts", dependencies=[Depends(require_auth)])
async def toggle_tts(suppress: bool = Query(...)):
    """
    Convenience endpoint to toggle TTS suppression.

    When suppressed, the device captures utterances silently without speaking.
    Useful for automated testing or reducing noise during analysis.

    Usage: POST /settings/tts?suppress=true
    """
    settings = device_settings.update(tts_suppressed=suppress)
    state = "suppressed" if suppress else "enabled"
    log_msg = f"TTS {state} (rev {settings.revision})"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {"tts_suppressed": settings.tts_suppressed, "revision": settings.revision}


# ── Device Registration & Auth Endpoints ──────────────────────────


class DeviceRegisterRequest(BaseModel):
    """Request body for device registration."""
    device_name: str
    device_serial: str = ""


@app.post("/device/register")
async def device_register(request: DeviceRegisterRequest):
    """
    Register a device for approval.

    The device calls this on first connect. The server creates a pending
    entry visible on the dashboard. Once approved, the device picks up
    its auth token via the /settings poll.
    """
    device = device_registry.register(request.device_name, request.device_serial)
    log_msg = f"Device registered: {device.device_id} ({device.device_name}) status={device.status}"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {
        "device_id": device.device_id,
        "status": device.status,
    }


@app.post("/device/approve/{device_id}")
async def device_approve(device_id: str):
    """
    Approve a pending device, generating its auth token.

    Called from the dashboard. After approval, the device's next /settings
    poll will include the token.
    """
    device = device_registry.approve(device_id)
    if device is None:
        return JSONResponse(status_code=404, content={"error": f"Device {device_id} not found"})

    log_msg = f"Device approved: {device_id} ({device.device_name})"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {
        "device_id": device.device_id,
        "status": device.status,
        "auth_token": device.auth_token,
    }


@app.post("/device/reject/{device_id}")
async def device_reject(device_id: str):
    """Reject a pending device."""
    device = device_registry.reject(device_id)
    if device is None:
        return JSONResponse(status_code=404, content={"error": f"Device {device_id} not found"})

    log_msg = f"Device rejected: {device_id} ({device.device_name})"
    logger.info(log_msg)
    await broadcast_log(log_msg)
    return {"device_id": device.device_id, "status": device.status}


@app.get("/device/pending")
async def device_pending():
    """Get all pending device registrations (for dashboard polling)."""
    return [d.model_dump() for d in device_registry.get_pending()]


@app.get("/device/all")
async def device_all():
    """Get all registered devices."""
    return [d.model_dump() for d in device_registry.get_all()]


# ── Gym Endpoints ─────────────────────────────────────────────────


@app.post("/gym/run", dependencies=[Depends(require_auth)])
async def gym_run(request: GymRunRequest):
    """
    Run a single backend + prompt against an utterance batch.
    Returns parsed issues, raw output, latency.
    """
    result = await gym_runner.run_single(request)
    return result.model_dump()


@app.post("/gym/compare", dependencies=[Depends(require_auth)])
async def gym_compare(request: GymCompareRequest):
    """
    Run a matrix of backends x prompt variants.
    Returns side-by-side comparison results.
    """
    summary = await gym_runner.run_compare(request)
    return summary.model_dump()


@app.get("/gym/history")
async def gym_history(limit: int = Query(default=50)):
    """Get past gym runs."""
    return [r.model_dump() for r in gym_runner.get_history(limit)]


@app.get("/gym/run/{run_id}")
async def gym_run_detail(run_id: str):
    """Get detailed results for a specific gym run."""
    run = gym_runner.get_run(run_id)
    if run is None:
        return JSONResponse(status_code=404, content={"error": f"Run {run_id} not found"})
    return run.model_dump()


@app.get("/gym/samples")
async def gym_samples():
    """
    Get sample utterance batches for gym testing.
    Pulls from current session history if available, plus built-in examples.
    """
    samples = []

    # Built-in sample: generic app with mixed issues
    samples.append({
        "name": "Mixed issues (built-in)",
        "utterances": [
            {"text": "Search. Button. Double tap to activate", "element": {"class_name": "android.widget.ImageButton", "content_description": "Search"}, "navigation": "SWIPE_RIGHT"},
            {"text": "Image", "element": {"class_name": "android.widget.ImageView"}, "navigation": "SWIPE_RIGHT"},
            {"text": "Button", "element": {"class_name": "android.widget.Button"}, "navigation": "SWIPE_RIGHT"},
            {"text": "ic_menu_overflow", "element": {"class_name": "android.widget.ImageButton"}, "navigation": "SWIPE_RIGHT"},
            {"text": "$49.99", "element": {"class_name": "android.widget.TextView"}, "navigation": "SWIPE_RIGHT"},
        ],
        "context": {"package_name": "com.example.shop", "activity_name": "ProductListActivity"},
    })

    # Built-in sample: login form
    samples.append({
        "name": "Login form (built-in)",
        "utterances": [
            {"text": "Edit text", "element": {"class_name": "android.widget.EditText"}, "navigation": "SWIPE_RIGHT"},
            {"text": "Edit text", "element": {"class_name": "android.widget.EditText"}, "navigation": "SWIPE_RIGHT"},
            {"text": "Button", "element": {"class_name": "android.widget.Button"}, "navigation": "SWIPE_RIGHT"},
            {"text": "Forgot password?", "element": {"class_name": "android.widget.TextView", "is_clickable": True}, "navigation": "SWIPE_RIGHT"},
        ],
        "context": {"package_name": "com.example.app", "activity_name": "LoginActivity"},
    })

    # Pull from session history if available
    current = session_manager.current
    if current and current.events:
        utterance_events = [
            e.data for e in current.events
            if e.event_type == "utterance" and "text" in e.data
        ]
        if utterance_events:
            samples.append({
                "name": f"Current session ({current.session_id})",
                "utterances": utterance_events[:20],
                "context": {},
            })

    return samples


# ── Gym Dashboard ─────────────────────────────────────────────────

GYM_HTML = """<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Model Gym</title>
<style>
body { font-family: -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #1a1a2e; color: #e0e0e0; }
h1 { color: #8be9fd; }
a { color: #8be9fd; }
.section { background: #16213e; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
.section h2 { margin-top: 0; color: #bd93f9; font-size: 16px; }
label { display: block; margin: 8px 0 4px; font-size: 13px; color: #aaa; }
input, textarea, select { width: 100%; padding: 8px; border: 1px solid #333; border-radius: 4px; background: #0f3460; color: #e0e0e0; font-family: monospace; font-size: 13px; box-sizing: border-box; }
textarea { min-height: 80px; resize: vertical; }
button { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin: 4px; }
.btn-primary { background: #8be9fd; color: #1a1a2e; font-weight: bold; }
.btn-secondary { background: #44475a; color: #e0e0e0; }
.btn-add { background: #50fa7b; color: #1a1a2e; font-size: 12px; padding: 6px 12px; }
.btn-remove { background: #ff5555; color: white; font-size: 11px; padding: 4px 8px; }
.backend-card { background: #0f3460; border: 1px solid #333; border-radius: 6px; padding: 12px; margin: 8px 0; }
.results-table { width: 100%; border-collapse: collapse; margin-top: 12px; }
.results-table th, .results-table td { border: 1px solid #333; padding: 10px; text-align: left; vertical-align: top; }
.results-table th { background: #0f3460; color: #bd93f9; }
.cell-success { background: #1a3a2e; }
.cell-fail { background: #3a1a1a; }
.raw-output { max-height: 200px; overflow-y: auto; font-size: 11px; background: #0a0a1a; padding: 8px; border-radius: 4px; white-space: pre-wrap; word-break: break-word; }
.stat { font-size: 12px; color: #aaa; }
.loading { color: #f1fa8c; font-style: italic; }
#status { margin: 12px 0; min-height: 24px; }
</style>
</head><body>
<h1>Model Gym</h1>
<p><a href="/">&larr; Dashboard</a></p>

<div class="section">
  <h2>Backends</h2>
  <div id="backends"></div>
  <button class="btn-add" onclick="addBackend('ollama')">+ Ollama</button>
  <button class="btn-add" onclick="addBackend('api')">+ API</button>
  <button class="btn-add" onclick="addBackend('cli')">+ CLI</button>
</div>

<div class="section">
  <h2>Prompt Variants</h2>
  <div id="prompts">
    <div class="backend-card">
      <label>Default system prompt (built-in)</label>
      <input type="text" value="default" disabled>
    </div>
  </div>
  <button class="btn-add" onclick="addPrompt()">+ Custom Prompt</button>
</div>

<div class="section">
  <h2>Utterances</h2>
  <label>Load sample:</label>
  <select id="sample-select" onchange="loadSample()">
    <option value="">-- Select sample --</option>
  </select>
  <label>Or paste JSON array:</label>
  <textarea id="utterances" placeholder='[{"text": "Button", "element": {"class_name": "android.widget.Button"}, "navigation": "SWIPE_RIGHT"}]'></textarea>
  <label>Context (optional JSON):</label>
  <input id="context" placeholder='{"package_name": "com.example", "activity_name": "Main"}'>
</div>

<div>
  <button class="btn-primary" onclick="runCompare()">Run Comparison</button>
  <button class="btn-secondary" onclick="runSingle()">Run First Backend Only</button>
</div>

<div id="status"></div>
<div id="results"></div>

<div class="section" style="margin-top: 24px">
  <h2>History</h2>
  <div id="history">Loading...</div>
</div>

<script>
let backendCount = 0;
let promptCount = 0;
let samples = [];

function addBackend(type) {
  backendCount++;
  const id = backendCount;
  const div = document.createElement('div');
  div.className = 'backend-card';
  div.id = 'backend-' + id;
  let fields = '';
  if (type === 'ollama') {
    fields = `<label>Model</label><input id="b${id}-model" value="phi4:14b-q4_K_M" placeholder="model name">`;
  } else if (type === 'api') {
    fields = `<label>API URL</label><input id="b${id}-url" placeholder="https://api.openai.com/v1/chat/completions">
      <label>Model</label><input id="b${id}-model" placeholder="gpt-4o">
      <label>Headers (JSON)</label><input id="b${id}-headers" placeholder='{"Authorization": "Bearer sk-..."}'>
      <label>Extra Body (JSON)</label><input id="b${id}-extra" placeholder="{}">`;
  } else {
    fields = `<label>Command (JSON array)</label><input id="b${id}-cmd" value='["claude", "--print"]' placeholder='["cmd", "arg1"]'>
      <label>Timeout (seconds)</label><input id="b${id}-timeout" value="120">`;
  }
  div.innerHTML = `<strong>${type.toUpperCase()}</strong>
    <button class="btn-remove" onclick="document.getElementById('backend-${id}').remove()" style="float:right">Remove</button>
    <input type="hidden" id="b${id}-type" value="${type}">
    <label>Name</label><input id="b${id}-name" value="${type}-${id}" placeholder="display name">
    ${fields}`;
  document.getElementById('backends').appendChild(div);
}

function addPrompt() {
  promptCount++;
  const id = promptCount;
  const div = document.createElement('div');
  div.className = 'backend-card';
  div.id = 'prompt-' + id;
  div.innerHTML = `<button class="btn-remove" onclick="document.getElementById('prompt-${id}').remove()" style="float:right">Remove</button>
    <label>Custom system prompt</label>
    <textarea id="p${id}-text" placeholder="You are an accessibility expert..."></textarea>`;
  document.getElementById('prompts').appendChild(div);
}

function collectBackends() {
  const backends = [];
  document.querySelectorAll('[id^="backend-"]').forEach(card => {
    const id = card.id.split('-')[1];
    const type = document.getElementById('b'+id+'-type').value;
    const cfg = { name: document.getElementById('b'+id+'-name').value, backend: type };
    if (type === 'ollama') {
      cfg.model = document.getElementById('b'+id+'-model').value;
    } else if (type === 'api') {
      cfg.api_url = document.getElementById('b'+id+'-url').value;
      cfg.api_model = document.getElementById('b'+id+'-model').value;
      try { cfg.api_headers = JSON.parse(document.getElementById('b'+id+'-headers').value || '{}'); } catch(e) { cfg.api_headers = {}; }
      try { cfg.api_extra_body = JSON.parse(document.getElementById('b'+id+'-extra').value || '{}'); } catch(e) { cfg.api_extra_body = {}; }
    } else {
      try { cfg.command = JSON.parse(document.getElementById('b'+id+'-cmd').value || '[]'); } catch(e) { cfg.command = []; }
      cfg.timeout_s = parseInt(document.getElementById('b'+id+'-timeout').value) || 120;
    }
    backends.push(cfg);
  });
  return backends;
}

function collectPrompts() {
  const prompts = [null]; // default is always first
  document.querySelectorAll('[id^="prompt-"]').forEach(card => {
    const id = card.id.split('-')[1];
    const text = document.getElementById('p'+id+'-text').value;
    if (text.trim()) prompts.push(text.trim());
  });
  return prompts;
}

function getUtterances() {
  try { return JSON.parse(document.getElementById('utterances').value); }
  catch(e) { return []; }
}

function getContext() {
  try { return JSON.parse(document.getElementById('context').value || 'null'); }
  catch(e) { return null; }
}

async function runCompare() {
  const backends = collectBackends();
  if (backends.length === 0) { alert('Add at least one backend'); return; }
  const utterances = getUtterances();
  if (utterances.length === 0) { alert('Add utterances'); return; }

  document.getElementById('status').innerHTML = '<span class="loading">Running comparison...</span>';
  document.getElementById('results').innerHTML = '';

  const resp = await fetch('/gym/compare', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      backends: backends,
      utterances: utterances,
      prompt_variants: collectPrompts(),
      context: getContext(),
    })
  });
  const data = await resp.json();
  document.getElementById('status').innerHTML = `Run ${data.run_id} completed in ${data.total_latency_ms}ms`;
  renderResults(data);
  loadHistory();
}

async function runSingle() {
  const backends = collectBackends();
  if (backends.length === 0) { alert('Add at least one backend'); return; }
  const utterances = getUtterances();
  if (utterances.length === 0) { alert('Add utterances'); return; }

  document.getElementById('status').innerHTML = '<span class="loading">Running...</span>';
  const prompts = collectPrompts();

  const resp = await fetch('/gym/run', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      backend: backends[0],
      utterances: utterances,
      prompt_override: prompts.length > 1 ? prompts[1] : null,
      context: getContext(),
    })
  });
  const cell = await resp.json();
  document.getElementById('status').innerHTML = `Done in ${cell.latency_ms}ms`;
  document.getElementById('results').innerHTML = renderCell(cell);
  loadHistory();
}

function renderResults(data) {
  if (!data.results || data.results.length === 0) {
    document.getElementById('results').innerHTML = '<p>No results</p>';
    return;
  }
  // Build matrix: rows = backends, cols = prompt variants
  const backendNames = [...new Set(data.results.map(r => r.backend_name))];
  const promptLabels = [...new Set(data.results.map(r => r.prompt_label))];

  let html = '<table class="results-table"><thead><tr><th>Backend</th>';
  promptLabels.forEach(p => { html += `<th>${p}</th>`; });
  html += '</tr></thead><tbody>';

  backendNames.forEach(bn => {
    html += `<tr><td><strong>${bn}</strong></td>`;
    promptLabels.forEach(pl => {
      const cell = data.results.find(r => r.backend_name === bn && r.prompt_label === pl);
      html += cell ? `<td class="${cell.success ? 'cell-success' : 'cell-fail'}">${renderCell(cell)}</td>` : '<td>-</td>';
    });
    html += '</tr>';
  });
  html += '</tbody></table>';
  document.getElementById('results').innerHTML = html;
}

function renderCell(cell) {
  const status = cell.success ? '&#10003;' : '&#10007; ' + cell.error;
  return `<div><strong>${status}</strong></div>
    <div class="stat">${cell.latency_ms}ms | ${cell.issues_found} issues | parse: ${cell.parse_success ? 'ok' : 'fail'}</div>
    ${cell.issues.length > 0 ? '<div class="stat">' + cell.issues.map(i => i.severity + ': ' + (i.issue || i.utterance || '')).join('<br>') + '</div>' : ''}
    <details><summary class="stat">Raw output</summary><div class="raw-output">${(cell.raw_output || '').replace(/</g,'&lt;')}</div></details>`;
}

async function loadSamples() {
  const resp = await fetch('/gym/samples');
  samples = await resp.json();
  const sel = document.getElementById('sample-select');
  samples.forEach((s, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = s.name + ' (' + s.utterances.length + ' utterances)';
    sel.appendChild(opt);
  });
}

function loadSample() {
  const idx = document.getElementById('sample-select').value;
  if (idx === '') return;
  const s = samples[parseInt(idx)];
  document.getElementById('utterances').value = JSON.stringify(s.utterances, null, 2);
  if (s.context && Object.keys(s.context).length > 0) {
    document.getElementById('context').value = JSON.stringify(s.context);
  }
}

async function loadHistory() {
  const resp = await fetch('/gym/history?limit=10');
  const runs = await resp.json();
  if (runs.length === 0) {
    document.getElementById('history').innerHTML = 'No runs yet';
    return;
  }
  document.getElementById('history').innerHTML = runs.map(r =>
    `<div class="stat">${r.run_id} | ${new Date(r.timestamp*1000).toLocaleTimeString()} | ${r.backend_count} backends x ${r.prompt_variant_count} prompts | ${r.total_latency_ms}ms</div>`
  ).join('');
}

// Init
loadSamples();
loadHistory();
addBackend('ollama'); // start with one Ollama backend
</script>
</body></html>"""


@app.get("/gym", response_class=HTMLResponse)
async def gym_page():
    """Model Gym — compare LLM backends and prompt variants."""
    return GYM_HTML


# ── Legacy command endpoint (kept for backwards compat) ───────────


@app.post("/command")
async def execute_command(command: SkillCommand) -> SkillResult:
    """
    Legacy command endpoint. Use /skill/execute for new integrations.
    """
    logger.info(f"Legacy command: {command.skill_name}")
    return SkillResult(
        success=False,
        message="Use /skill/execute for remote skill execution",
    )


# ── Main ──────────────────────────────────────────────────────────


def main():
    parser = argparse.ArgumentParser(description="TalkBack Agent Analysis Server")
    parser.add_argument("--host", default="0.0.0.0", help="Bind host (default: 0.0.0.0)")
    parser.add_argument("--port", type=int, default=8080, help="Bind port (default: 8080)")
    parser.add_argument(
        "--model",
        default="phi4:14b-q4_K_M",
        help="Ollama model name (default: phi4:14b-q4_K_M)",
    )
    parser.add_argument("--no-mdns", action="store_true", help="Disable mDNS/Bonjour discovery")
    parser.add_argument("--log-level", default="info", help="Log level (default: info)")

    args = parser.parse_args()

    logging.basicConfig(
        level=getattr(logging, args.log_level.upper()),
        format="%(asctime)s [%(name)s] %(levelname)s: %(message)s",
    )

    # Pass config to app state
    app.state.model_name = args.model
    app.state.mdns_enabled = not args.no_mdns
    app.state.port = args.port

    logger.info(f"Starting server on {args.host}:{args.port}")
    logger.info(f"Model: {args.model}")
    logger.info(f"mDNS: {'enabled' if not args.no_mdns else 'disabled'}")
    logger.info("")
    logger.info("Endpoints:")
    logger.info(f"  Dashboard:  http://localhost:{args.port}/")
    logger.info(f"  Swagger UI: http://localhost:{args.port}/docs")
    logger.info(f"  Health:     http://localhost:{args.port}/health")
    logger.info("")
    logger.info("Setup:")
    logger.info("  1. Connect Android device via USB")
    logger.info(f"  2. Run: adb reverse tcp:{args.port} tcp:{args.port}")
    logger.info("  3. Enable TalkBack Agent in Accessibility settings")
    logger.info("")

    uvicorn.run(
        app,
        host=args.host,
        port=args.port,
        log_level=args.log_level,
    )


if __name__ == "__main__":
    main()
